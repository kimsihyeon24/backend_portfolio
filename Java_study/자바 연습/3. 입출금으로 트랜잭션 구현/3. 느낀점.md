느낀점

12.27

setAutoCommit은 원래 True이다.

이것을 FALSE로 해주어야만 한번의 명령에 두번의 트랜잭션이 발생할 때 원자성을 보장할 수 있다.

commit되지 못한 데이터는 작업 종료 시 모두 없어진다.

코드 단계에서 생각해보면 db와 연결하는 작업을 dao에서 하지 않고, service 수준에서 처리함으로써 코드의 복잡성을 줄이고, commit되는 영역과 그전에 올라가는 영역을 완벽하게 분리가 가능했다.

그다음 뭘 해볼수 있을까 싶긴한데 예외처리와 추가적인 작업을 해보고 내일 마무리하겠다.



12.28

동시성 이슈를 확인하는데 연습을 했다.

무작정 쓰레드 풀을 확인해 await를 활용하여 동시성 이슈를 만들어냈다.

이후 이걸 처리하는 작업은 크게 3가지가 존재하는데

1. UPDATE SET에서 WHERE문에 대한 조건을 걸면 db에서 lock이 생성돼 짧은 순간에 lock을 생성후 반환해 효율적인 동시성 제어 가능
2. FOR UPDATE 같은 경우에는 처리가 어려울시 sql문 전체에 대한 락을 걸어 확인 -> 변경 -> 헤재 라는 과정을 거침으로 조금 더 시간 발생 하지만 여전히 효율적이고 분기 처리가 어려울시 사용하면 효율적
3. synchronized를 사용, 이건 매우 시간이 오래 걸리는 작업 -> JVM내부락이라 row락인 db보다 시간이 오래걸림 또한 서버를 증설해서 작업시 서버 단위로 락이 발생하기 때문에 락 설정 이유 사라짐 하지만 서버가 1개이고 간단한 작업일시 사용하면 유용
